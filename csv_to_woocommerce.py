#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script para transformar CSV de inventario al formato WooCommerce
Convierte archivo CSV con m√∫ltiples p√°ginas a formato compatible con WooCommerce
"""

import pandas as pd
import sys
import os
import requests
import urllib.parse
import re
import json
from datetime import datetime

class ImageFetcher:
    """
    Clase para obtener im√°genes de productos desde APIs gratuitas
    """
    def __init__(self):
        self.cache_file = 'image_cache.json'
        self.cache = self.load_cache()
        self.images_folder = 'product_images'  # Nueva carpeta para im√°genes locales
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'WooCommerce-CSV-Converter/1.0'
        })
        
        # Crear carpeta de im√°genes si no existe
        if not os.path.exists(self.images_folder):
            os.makedirs(self.images_folder)
            print(f"üìÅ Carpeta creada: {self.images_folder}")
    
    def load_cache(self):
        """Carga el cache de im√°genes desde archivo"""
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_cache(self):
        """Guarda el cache de im√°genes en archivo"""
        try:
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(self.cache, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"‚ö†Ô∏è  Advertencia: No se pudo guardar el cache de im√°genes: {e}")
    
    def clean_product_name_for_search(self, product_name):
        """Limpia el nombre del producto para una mejor b√∫squeda"""
        if not product_name:
            return ""
        
        # Convertir a min√∫sculas y limpiar
        cleaned = product_name.lower().strip()
        
        # Remover caracteres especiales y n√∫meros sueltos
        cleaned = re.sub(r'[^\w\s-]', ' ', cleaned)
        cleaned = re.sub(r'\b\d+\b', '', cleaned)
        
        # Remover palabras muy cortas y espacios extra
        words = [word for word in cleaned.split() if len(word) > 2]
        
        return ' '.join(words[:3])  # M√°ximo 3 palabras para mejor b√∫squeda
    
    def get_unsplash_image(self, product_name):
        """
        Obtiene imagen desde Unsplash usando su API p√∫blica (sin API key)
        Utiliza la funci√≥n de b√∫squeda de Unsplash Source
        """
        # Nota: Deshabilitado temporalmente debido a problemas de conectividad
        return None
    
    def get_picsum_image(self, product_name):
        """
        Obtiene imagen placeholder desde Lorem Picsum
        """
        # Nota: Deshabilitado temporalmente debido a problemas de conectividad
        return None
    
    def get_placeholder_image(self, product_name):
        """
        Obtiene imagen placeholder simple y confiable
        """
        try:
            # Generar color basado en el nombre del producto
            product_hash = abs(hash(product_name)) % 16777215  # Color hexadecimal
            color = f"{product_hash:06x}"
            
            # Usar placeholder.com que es muy confiable
            text = urllib.parse.quote(product_name[:10].replace(' ', '+'))
            url = f"https://via.placeholder.com/400x400/{color}/ffffff?text={text}"
            
            print(f"   üîç Probando Placeholder URL: {url}")
            
            # Esta URL siempre funciona, no necesitamos verificar
            print(f"   ‚úÖ Placeholder OK: {url}")
            return url
                
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Error con Placeholder para '{product_name}': {e}")
        
        return None
    
    def get_simple_placeholder_image(self, product_name):
        """
        Genera una URL de imagen placeholder simple y confiable
        """
        try:
            # Generar color basado en el nombre del producto
            product_hash = abs(hash(product_name))
            color_codes = ['FF6B6B', '4ECDC4', '45B7D1', 'FFA07A', '98D8C8', 'F7DC6F', 'BB8FCE', '85C1E9']
            color = color_codes[product_hash % len(color_codes)]
            
            # Crear texto corto para la imagen
            text = product_name[:8].replace(' ', '+').upper()
            
            # Usar DummyImage.com que es muy estable
            url = f"https://dummyimage.com/400x400/{color}/ffffff&text={text}"
            
            print(f"   üé® Generando placeholder: {url}")
            return url
                
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Error generando placeholder para '{product_name}': {e}")
            # Fallback: URL est√°tica b√°sica
            return "https://dummyimage.com/400x400/cccccc/ffffff&text=Producto"
    
    def get_product_image(self, product_name):
        """
        Obtiene imagen para un producto, usando cache si est√° disponible
        """
        if not product_name or not product_name.strip():
            return None
        
        # Verificar cache
        cache_key = product_name.strip().lower()
        if cache_key in self.cache:
            cached_url = self.cache[cache_key]
            if cached_url:  # Solo retornar si hay URL v√°lida
                print(f"   üíæ Imagen en cache para: {product_name}")
                return cached_url
        
        print(f"   üîç Buscando imagen para: {product_name}")
        
        # Intentar obtener imagen de Unsplash primero
        image_url = self.get_unsplash_image(product_name)
        
        # Si falla, usar imagen de Picsum
        if not image_url:
            print(f"   ‚è≠Ô∏è  Unsplash fall√≥, probando Picsum...")
            image_url = self.get_picsum_image(product_name)
        
        # Si todo falla, usar placeholder confiable
        if not image_url:
            print(f"   ‚è≠Ô∏è  Picsum fall√≥, usando placeholder simple...")
            image_url = self.get_simple_placeholder_image(product_name)
        
        # Guardar en cache (incluso si es None para evitar buscar de nuevo)
        self.cache[cache_key] = image_url
        
        if image_url:
            print(f"   ‚úÖ Imagen final: {image_url}")
        else:
            print(f"   ‚ùå No se pudo obtener imagen")
        
        return image_url
    
    def download_image_locally(self, image_url, product_name, product_id):
        """
        Descarga una imagen y la guarda localmente
        """
        try:
            # Generar nombre de archivo seguro
            safe_name = re.sub(r'[^\w\s-]', '', product_name.lower())
            safe_name = re.sub(r'[-\s]+', '-', safe_name)
            filename = f"producto-{product_id:04d}-{safe_name[:20]}.jpg"
            filepath = os.path.join(self.images_folder, filename)
            
            # Si el archivo ya existe, retornar la ruta
            if os.path.exists(filepath):
                print(f"   üìÅ Imagen local existente: {filename}")
                return filepath
            
            print(f"   ‚¨áÔ∏è  Descargando imagen: {filename}")
            
            # Descargar la imagen
            response = self.session.get(image_url, timeout=10, stream=True)
            response.raise_for_status()
            
            # Guardar la imagen
            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            print(f"   ‚úÖ Imagen descargada: {filepath}")
            return filepath
            
        except Exception as e:
            print(f"   ‚ùå Error descargando imagen: {e}")
            return None
    
    def get_woocommerce_compatible_image(self, product_name, product_id):
        """
        Obtiene una imagen compatible con WooCommerce (descargada localmente)
        """
        if not product_name or not product_name.strip():
            return None
        
        # Verificar cache
        cache_key = f"{product_name.strip().lower()}_{product_id}"
        if cache_key in self.cache:
            cached_path = self.cache[cache_key]
            if cached_path and os.path.exists(cached_path):
                print(f"   üíæ Imagen local en cache: {cached_path}")
                return cached_path
        
        print(f"   üîç Procesando imagen para: {product_name}")
        
        # Generar URL de placeholder
        image_url = self.get_simple_placeholder_image(product_name)
        
        if image_url:
            # Descargar imagen localmente
            local_path = self.download_image_locally(image_url, product_name, product_id)
            
            if local_path:
                # Guardar en cache
                self.cache[cache_key] = local_path
                return local_path
        
        return None

def leer_csv_con_paginas(archivo_csv):
    """
    Lee un archivo CSV que contiene m√∫ltiples p√°ginas/hojas
    y extrae los nombres de las p√°ginas como categor√≠as
    
    Args:
        archivo_csv (str): Ruta al archivo CSV original
    
    Returns:
        dict: Diccionario con datos de cada p√°gina
    """
    try:
        # Intentamos leer el archivo como Excel primero (si tiene m√∫ltiples hojas)
        if archivo_csv.endswith(('.xlsx', '.xls')):
            print("Detectado archivo Excel, leyendo todas las hojas...")
            xl_file = pd.ExcelFile(archivo_csv)
            paginas_data = {}
            
            for nombre_pagina in xl_file.sheet_names:
                print(f"Leyendo p√°gina: {nombre_pagina}")
                df = pd.read_excel(archivo_csv, sheet_name=nombre_pagina)
                paginas_data[nombre_pagina] = df
                
            return paginas_data
            
        else:
            # Si es CSV, leemos como una sola p√°gina
            print("Detectado archivo CSV, leyendo como p√°gina √∫nica...")
            df = pd.read_csv(archivo_csv, encoding='utf-8')
            # Usamos el nombre del archivo como categor√≠a por defecto
            nombre_categoria = os.path.splitext(os.path.basename(archivo_csv))[0]
            return {nombre_categoria: df}
            
    except Exception as e:
        print(f"Error al leer el archivo: {e}")
        return None

def verificar_estructura_datos(paginas_data):
    """
    Verifica que los datos tengan la estructura esperada
    
    Args:
        paginas_data (dict): Datos de las p√°ginas
    
    Returns:
        bool: True si la estructura es correcta
    """
    columnas_esperadas = ['PRODUCTO', 'PRECIO', '0,3', 'TOTAL']
    
    for nombre_pagina, df in paginas_data.items():
        print(f"\n--- Verificando p√°gina: {nombre_pagina} ---")
        print(f"N√∫mero de filas: {len(df)}")
        print(f"Columnas encontradas: {list(df.columns)}")
        
        # Verificar si tiene las columnas esperadas
        columnas_faltantes = []
        for col in columnas_esperadas:
            if col not in df.columns:
                columnas_faltantes.append(col)
        
        if columnas_faltantes:
            print(f"‚ö†Ô∏è  Columnas faltantes: {columnas_faltantes}")
        else:
            print("‚úÖ Todas las columnas esperadas est√°n presentes")
            
        # Mostrar primeras filas para verificar formato
        print("Primeras 3 filas:")
        print(df.head(3))
        
    return True

def crear_estructura_woocommerce():
    """
    Define la estructura de columnas requerida por WooCommerce
    
    Returns:
        list: Lista de nombres de columnas para WooCommerce
    """
    return [
        'ID', 'Tipo', 'SKU', 'GTIN', 'Nombre', 'Publicado', '¬øEst√° destacado?', 
        'Visibilidad en el cat√°logo', 'Descripci√≥n corta', 'Descripci√≥n', 
        'D√≠a en que empieza el precio rebajado', 'D√≠a en que termina el precio rebajado',
        'Estado del impuesto', 'Clase de impuesto', '¬øExistencias?', 'Inventario',
        'Cantidad de bajo inventario', '¬øPermitir reservas de productos agotados?',
        '¬øVendido individualmente?', 'Peso (kg)', 'Longitud (cm)', 'Anchura (cm)',
        'Altura (cm)', '¬øPermitir valoraciones de clientes?', 'Nota de compra',
        'Precio rebajado', 'Precio normal', 'Categor√≠as', 'Etiquetas', 
        'Clase de env√≠o', 'Im√°genes', 'L√≠mite de descargas',
        'D√≠as de caducidad de la descarga', 'Superior', 'Productos agrupados',
        'Ventas dirigidas', 'Ventas cruzadas', 'URL externa', 'Texto del bot√≥n',
        'Posici√≥n', 'Marcas'
    ]

def procesar_datos_a_woocommerce(paginas_data, solo_ejemplo=False, agregar_imagenes=False):
    """
    Convierte los datos del inventario al formato WooCommerce
    
    Args:
        paginas_data (dict): Datos de las p√°ginas del archivo original
        solo_ejemplo (bool): Si es True, procesa solo 100 productos variados para prueba
        agregar_imagenes (bool): Si es True, busca im√°genes autom√°ticamente para los productos
    
    Returns:
        pd.DataFrame: DataFrame con formato WooCommerce
    """
    print("\n=== Procesando datos a formato WooCommerce ===")
    
    if solo_ejemplo:
        print("üî¨ MODO EJEMPLO: Procesando solo 100 productos variados para prueba")
    
    if agregar_imagenes:
        print("üñºÔ∏è  MODO IM√ÅGENES: Descargando im√°genes localmente para WooCommerce")
        image_fetcher = ImageFetcher()
    else:
        image_fetcher = None
    
    # Crear lista para almacenar todos los productos
    productos_woocommerce = []
    contador_id = 1
    productos_procesados = 0
    max_productos = 100 if solo_ejemplo else float('inf')
    
    for nombre_pagina, df in paginas_data.items():
        if productos_procesados >= max_productos:
            break
            
        print(f"Procesando p√°gina: {nombre_pagina} ({len(df)} productos)")
        
        # Limpiar datos: eliminar filas vac√≠as
        df_limpio = df.dropna(subset=['PRODUCTO'])
        
        # Si es modo ejemplo, tomar solo algunos productos de cada categor√≠a
        if solo_ejemplo:
            # Tomar m√°ximo 4 productos por categor√≠a para variedad
            productos_por_categoria = min(4, len(df_limpio))
            if productos_procesados + productos_por_categoria > max_productos:
                productos_por_categoria = max_productos - productos_procesados
            df_limpio = df_limpio.head(productos_por_categoria)
        
        for index, fila in df_limpio.iterrows():
            if productos_procesados >= max_productos:
                break
            try:
                # Limpiar y calcular precio base (TOTAL / 1.03)
                total_str = str(fila['TOTAL']).strip()
                
                # Manejar casos especiales
                if pd.isna(fila['TOTAL']) or total_str in ['#VALUE!', 'nan', '']:
                    precio_base = 0
                else:
                    # Limpiar formato: remover espacios, ‚Ç¨, y convertir comas a puntos
                    total_limpio = total_str.replace('‚Ç¨', '').replace(' ', '').replace(',', '.')
                    try:
                        precio_total = float(total_limpio)
                        precio_base = round(precio_total / 1.03, 2) if precio_total > 0 else 0
                    except ValueError:
                        precio_base = 0
                
                # Crear producto para WooCommerce
                producto_wc = {
                    'ID': contador_id,
                    'Tipo': 'simple',
                    'SKU': f"SKU-{contador_id:04d}",
                    'GTIN': '',
                    'Nombre': str(fila['PRODUCTO']).strip(),
                    'Publicado': 1,
                    '¬øEst√° destacado?': 0,
                    'Visibilidad en el cat√°logo': 'visible',
                    'Descripci√≥n corta': f"Producto de la categor√≠a {nombre_pagina}",
                    'Descripci√≥n': f"Producto {str(fila['PRODUCTO']).strip()} de la categor√≠a {nombre_pagina}",
                    'D√≠a en que empieza el precio rebajado': '',
                    'D√≠a en que termina el precio rebajado': '',
                    'Estado del impuesto': 'taxable',
                    'Clase de impuesto': 'standard',
                    '¬øExistencias?': 1,
                    'Inventario': 100,  # Valor por defecto
                    'Cantidad de bajo inventario': 5,
                    '¬øPermitir reservas de productos agotados?': 0,
                    '¬øVendido individualmente?': 0,
                    'Peso (kg)': '',
                    'Longitud (cm)': '',
                    'Anchura (cm)': '',
                    'Altura (cm)': '',
                    '¬øPermitir valoraciones de clientes?': 1,
                    'Nota de compra': '',
                    'Precio rebajado': '',
                    'Precio normal': precio_base,
                    'Categor√≠as': nombre_pagina,
                    'Etiquetas': nombre_pagina.lower().replace(' ', '-'),
                    'Clase de env√≠o': '',
                    'Im√°genes': '',
                    'L√≠mite de descargas': '',
                    'D√≠as de caducidad de la descarga': '',
                    'Superior': '',
                    'Productos agrupados': '',
                    'Ventas dirigidas': '',
                    'Ventas cruzadas': '',
                    'URL externa': '',
                    'Texto del bot√≥n': '',
                    'Posici√≥n': contador_id,
                    'Marcas': ''
                }
                
                # Agregar imagen del producto si est√° habilitado
                if agregar_imagenes and image_fetcher:
                    nombre_producto = str(fila['PRODUCTO']).strip()
                    imagen_path = image_fetcher.get_woocommerce_compatible_image(nombre_producto, contador_id)
                    if imagen_path:
                        # Convertir a ruta relativa para el CSV
                        producto_wc['Im√°genes'] = imagen_path
                
                productos_woocommerce.append(producto_wc)
                contador_id += 1
                productos_procesados += 1
                
            except Exception as e:
                print(f"Error procesando producto en fila {index}: {e}")
                continue
    
    # Crear DataFrame final
    columnas_wc = crear_estructura_woocommerce()
    df_woocommerce = pd.DataFrame(productos_woocommerce, columns=columnas_wc)
    
    # Guardar cache de im√°genes si se utiliz√≥
    if agregar_imagenes and image_fetcher:
        image_fetcher.save_cache()
        print(f"üíæ Cache de im√°genes guardado en {image_fetcher.cache_file}")
        
        # Mostrar resumen de im√°genes descargadas
        imagenes_con_path = df_woocommerce[df_woocommerce['Im√°genes'] != '']['Im√°genes']
        if len(imagenes_con_path) > 0:
            print(f"üìÅ {len(imagenes_con_path)} im√°genes descargadas en: {image_fetcher.images_folder}")
            print("üìã IMPORTANTE: Sube la carpeta 'product_images' a tu WordPress en /wp-content/uploads/")
    
    print(f"‚úÖ Procesamiento completado: {len(df_woocommerce)} productos convertidos")
    return df_woocommerce

def exportar_csv_woocommerce(df_woocommerce, nombre_archivo=None):
    """
    Exporta el DataFrame al formato CSV compatible con WooCommerce
    
    Args:
        df_woocommerce (pd.DataFrame): DataFrame con datos de WooCommerce
        nombre_archivo (str): Nombre del archivo de salida
    
    Returns:
        str: Ruta del archivo exportado
    """
    if nombre_archivo is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        nombre_archivo = f"productos_woocommerce_{timestamp}.csv"
    
    try:
        # Exportar a CSV con codificaci√≥n UTF-8 y separador de coma
        df_woocommerce.to_csv(
            nombre_archivo, 
            index=False, 
            encoding='utf-8-sig',  # UTF-8 con BOM para compatibilidad con Excel
            sep=','
        )
        
        print(f"‚úÖ Archivo exportado exitosamente: {nombre_archivo}")
        print(f"üìä Total de productos: {len(df_woocommerce)}")
        print(f"üìÅ Ubicaci√≥n: {os.path.abspath(nombre_archivo)}")
        
        return nombre_archivo
        
    except Exception as e:
        print(f"‚ùå Error al exportar el archivo: {e}")
        return None

def mostrar_resumen_conversion(df_woocommerce):
    """
    Muestra un resumen de la conversi√≥n realizada
    
    Args:
        df_woocommerce (pd.DataFrame): DataFrame convertido
    """
    print("\n=== RESUMEN DE CONVERSI√ìN ===")
    print(f"Total de productos convertidos: {len(df_woocommerce)}")
    
    # Resumen por categor√≠as
    categorias = df_woocommerce['Categor√≠as'].value_counts()
    print(f"\nProductos por categor√≠a:")
    for categoria, cantidad in categorias.items():
        print(f"  üìÅ {categoria}: {cantidad} productos")
    
    # Resumen de precios
    precios = df_woocommerce['Precio normal'].astype(float)
    print(f"\nResumen de precios:")
    print(f"  üí∞ Precio promedio: {precios.mean():.2f}‚Ç¨")
    print(f"  üí∞ Precio m√≠nimo: {precios.min():.2f}‚Ç¨")
    print(f"  üí∞ Precio m√°ximo: {precios.max():.2f}‚Ç¨")
    
    # Mostrar primeros productos como ejemplo
    print(f"\nPrimeros 3 productos convertidos:")
    columnas_muestra = ['Nombre', 'Precio normal', 'Categor√≠as', 'SKU']
    print(df_woocommerce[columnas_muestra].head(3).to_string(index=False))

def main():
    """
    Funci√≥n principal del script
    """
    print("=== Script de Conversi√≥n CSV a WooCommerce ===")
    
    # Verificar flags de comandos
    solo_ejemplo = '--ejemplo' in sys.argv or '-e' in sys.argv
    agregar_imagenes = '--imagenes' in sys.argv or '-i' in sys.argv
    
    if solo_ejemplo:
        print("üî¨ MODO EJEMPLO ACTIVADO: Se procesar√°n solo 100 productos variados")
    
    if agregar_imagenes:
        print("üñºÔ∏è  MODO IM√ÅGENES ACTIVADO: Se buscar√°n im√°genes autom√°ticamente")
    
    if solo_ejemplo and agregar_imagenes:
        print("üîÑ COMBINACI√ìN: Modo ejemplo + im√°genes autom√°ticas")
    
    print("Paso 1: Lectura y verificaci√≥n del archivo original\n")
    
    # CONFIGURACI√ìN: Cambia esta ruta por la ubicaci√≥n de tu archivo
    archivo_original = "Productos.xlsx"  # Archivo Excel con m√∫ltiples p√°ginas
    
    # Verificar si el archivo existe
    if not os.path.exists(archivo_original):
        print(f"‚ùå Error: No se encuentra el archivo {archivo_original}")
        print("Por favor, coloca tu archivo CSV/Excel en la misma carpeta que este script")
        print("o modifica la variable 'archivo_original' con la ruta correcta")
        return
    
    # Leer el archivo
    print(f"Leyendo archivo: {archivo_original}")
    paginas_data = leer_csv_con_paginas(archivo_original)
    
    if paginas_data is None:
        print("‚ùå Error al leer el archivo")
        return
    
    # Verificar estructura
    if verificar_estructura_datos(paginas_data):
        print("\n‚úÖ OK - El archivo se ha le√≠do correctamente")
        print(f"‚úÖ OK - Se encontraron {len(paginas_data)} p√°gina(s)")
        print("‚úÖ OK - Nombres de p√°ginas detectados:")
        for nombre_pagina in paginas_data.keys():
            print(f"   üìÅ {nombre_pagina}")
        
        print("\nüéØ Procesando datos y creando formato WooCommerce...")
        
        # PASO 2: PROCESAR DATOS A FORMATO WOOCOMMERCE
        df_woocommerce = procesar_datos_a_woocommerce(paginas_data, solo_ejemplo, agregar_imagenes)
        
        if df_woocommerce is not None and len(df_woocommerce) > 0:
            # PASO 3: MOSTRAR RESUMEN
            mostrar_resumen_conversion(df_woocommerce)
            
            # PASO 4: EXPORTAR A CSV
            print("\n=== EXPORTANDO ARCHIVO CSV ===")
            archivo_exportado = exportar_csv_woocommerce(df_woocommerce)
            
            if archivo_exportado:
                print(f"\nüéâ ¬°CONVERSI√ìN COMPLETADA EXITOSAMENTE!")
                print(f"üìÑ Archivo listo para WooCommerce: {archivo_exportado}")
                print(f"üîÑ Ahora puedes importar este archivo en tu tienda WooCommerce")
            else:
                print("‚ùå Error al exportar el archivo")
        else:
            print("‚ùå Error: No se pudieron procesar los datos")
        
    else:
        print("‚ùå Error en la estructura de datos")

if __name__ == "__main__":
    # Mostrar ayuda si se solicita
    if '--ayuda' in sys.argv or '-h' in sys.argv or '--help' in sys.argv:
        print("=== AYUDA - Script de Conversi√≥n CSV a WooCommerce ===")
        print("Uso: python csv_to_woocommerce.py [opciones]")
        print("\nOpciones:")
        print("  --ejemplo, -e     Procesa solo 100 productos variados para prueba")
        print("  --imagenes, -i    Agrega im√°genes autom√°ticamente desde internet")
        print("  --ayuda, -h       Muestra esta ayuda")
        print("\nEjemplos:")
        print("  python csv_to_woocommerce.py")
        print("  python csv_to_woocommerce.py --ejemplo")
        print("  python csv_to_woocommerce.py --imagenes")
        print("  python csv_to_woocommerce.py --ejemplo --imagenes")
        print("  python csv_to_woocommerce.py -e -i")
        sys.exit(0)
    
    main()
